# 图1
- 实验配置与描述：当没有任何优化时，每次实验仅增加参与完成计算的线程数目，线程的数量为单线程、2线程、4线程、16线程、32线程、64线程。这些线程都是在同一节点上的。因此不存在不同节点中内存访问的问题。在实验期间，可能存在访问冲突的变量已使用reduction避免冲突。

- 实验结果为：单线程为基准，2线程加速比为1.01,4线程加速比为1.05,16线程加速比为1.18,32线程加速比为1.05,64线程加速比为1.19

- 分析：实验结果可得，当完成相同迭代数、相同鱼总数（2^22尾）的任务时，线程数数增加，加速比增加。当线程数为16、64时加速比分别达到1.18和1.19。通过观察可得，32线程的情况下获得的加速比低于16线程、64线程的加速比，这有可能由以下几点原因造成：
1. reduction 的引用导致一个线程更新共享变量时，其他线程需要等待更新的完成。
2. 非均匀的内存访问，当使用32线程时可能存在有些线程所在的核心与存放数据的内存的距离较远，产生了一定的访问延迟。
3. 更多的线程可能导致更频繁的缓存未命中，继而需要从内存中读取数据，导致了性能的降低。

# 图2
- 实验配置与描述：在这个实验中使用16线程完成任务，迭代500轮，每次实验中的鱼的总数不同，分别为2^6, 2^10, 2^14, 2^18, 2^22。由于鱼群总数不同，为了实验结果可以在同一尺度下对比，将完成任务所消耗的时间除以当前实验中鱼群的总数，得到完成一条鱼迭代500轮所需要的时间。

- 实验结果为：以池塘中存在2^6条鱼，每条鱼完成500轮迭代所需的时间为基准值。2^10条鱼时加速比为15.72， 2^14条鱼时加速比为562.20, 2^18条鱼时加速比为72017.19, 2^22条鱼时加速比为7237.91。

- 分析：通过观察实验结果，可以得到如下的现象：
1. 当问题规模较大时，计算任务更容易均匀分布在所有处理器或线程上，从而提高资源利用率。
2. 随着问题规模增加，加速比先显著增加，但在2^22条鱼的实验条件下，加速比有所降低。
3. 对于大规模问题，计算通常会占用更大比例的时间，而与其他线程或处理器进行数据交换和通信的时间相对会减少。
4. 由于没有使用栈对部分堆上的数据进行复制，导致了加速比不能进一步上升。并且由于数据量的上升，内存访问的次数多了，产生了瓶颈，继而导致了加速比下降。

# 图3
- 实验配置与描述：
  
- 实验结果为：

- 分析：